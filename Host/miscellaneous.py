import hashlib
import secrets
import random



def generate_sw() -> str:
    """
    Генерация случайной 128-битной строки.
    
    Использует secrets.token_hex() для создания криптографически стойкой
    случайной последовательности.
    
    Args:
        Нет аргументов
        
    Returns:
        str: Случайная строка из 32 шестнадцатеричных символов
    
    Примеры:
        generate_sw() -> "f7a9c2b4e1d8f3a6c5b2e7d4f1a8c3b9"
    """
    # secrets.token_hex(n) генерирует n случайных байт и 
    # преобразует их в шестнадцатеричную строку
    # 16 байт * 8 = 128 бит
    # Каждый байт кодируется 2 hex символами
    # Поэтому на выходе получаем строку длиной 32 символа (16 * 2)
    return secrets.token_hex(16)

def hash_md5(data: str) -> str:
    """
    MD5 хеширование строки.
    Принимает строку и возвращает её MD5 хеш в виде 32-символьной hex строки.
    
    Args:
        data (str): Входная строка для хеширования
        
    Returns:
        str: MD5 хеш в шестнадцатеричном представлении
    """
    # encode() конвертирует строку в байты, так как md5 работает с байтами
    # По умолчанию использует UTF-8 кодировку
    # Пример: "hello" -> b"hello"
    
    # hashlib.md5() создает объект хеширования MD5
    # После хеширования получаем 16-байтовое значение
    
    # hexdigest() конвертирует 16 байт хеша в 32-символьную строку в hex формате
    # Каждый байт представляется двумя hex цифрами
    # Пример: b"\x5d\x41\x40" -> "5d4140"
    return hashlib.md5(data.encode()).hexdigest()

def generate_odd_64bit() -> int:
    """Генерация 64-битного нечетного числа."""
    num = random.getrandbits(64)
    if num % 2 == 0:
        num += 1
    return num

def jacobi_symbol(a: int, n: int) -> int:
    """
    Вычисление символа Якоби (a/n).
    Символ Якоби равен:
     0 если a и n имеют общий делитель
    +1 если a является квадратичным вычетом по модулю n
    -1 если a является квадратичным невычетом по модулю n

    Пусть p - простое нечетное число. Тогда число a, такое, что НОД(a, p) = 1,
    называется вычетом степени n, если:
    
        x^n = a (mod p)

    В обратном случае число a называется невычетом степени n. При n = 2 вычет a наз-ся квадратичным.

    Args:
        a (int): Верхнее число
        n (int): Нижнее число (должно быть нечетным положительным)
    
    Returns:
        int: Значение символа Якоби (-1, 0 или 1)
    """
    # Базовые случаи
    if a == 0:  # Если a = 0, символ Якоби = 0
        return 0
    if a == 1:  # Если a = 1, символ Якоби = 1
        return 1
    
    # Свойство 1: Если a отрицательное
    # (a/n) = (-1)^((n-1)/2) * (-a/n)
    if a < 0:
        return (-1) ** ((n-1)//2) * jacobi_symbol(-a, n)
    
    # Свойство 2: Если a четное
    # (2/n) = (-1)^((n^2-1)/8)
    if a % 2 == 0:
        return (-1) ** ((n*n-1)//8) * jacobi_symbol(a//2, n)
    
    # Свойство 3: Если a >= n, можно взять остаток
    if a >= n:
        return jacobi_symbol(a % n, n)
    
    # Свойство 4: Квадратичный закон взаимности
    # Для двух различных нечетных простых чисел a и n символы Якоби связаны формулой:
     # (a/n) = (-1)^((a-1)(n-1)/4) * (n/a)
    return (-1) ** ((a-1)*(n-1)//4) * jacobi_symbol(n % a, a)

def solovay_strassen_test(n: int, k: int = 10) -> bool:
    """
    Вероятностный тест на простоту числа методом Соловея-Штрассена.
    
    Принцип работы:
    Для простого числа n и любого числа a, взаимно простого с n:
    a^((n-1)/2) ≡ (a/n) (mod n), где (a/n) - символ Якоби
    
    Args:
        n (int): Тестируемое число
        k (int): Количество раундов тестирования (больше k = выше точность)
    
    Returns:
        bool: True если число вероятно простое, False если составное
    """
    # Проверка базовых случаев
    if n == 2:
        return True
    if n < 2 or n % 2 == 0:  # Четные числа кроме 2 не простые
        return False
    
    # Проводим k раундов тестирования
    for _ in range(k):
        # Выбираем случайное число a из интервала [2, n-1]
        a = random.randrange(2, n)
        
        # Вычисляем символ Якоби (a/n)
        x = jacobi_symbol(a, n)
        
        # Если x = 0, значит a и n имеют общий делитель => n составное
        # Если a^((n-1)/2) mod n ≠ символу Якоби mod n, то n составное
        if x == 0 or mod_exp(a, (n-1)//2, n) != (x % n):
            return False
            
    # Если все тесты пройдены, число вероятно простое
    # Вероятность ошибки не более 1/2^k
    return True

def generate_prime_512bit() -> int:
    """
    Генерация 512-битного простого числа методом Соловея-Штрассена.
    
    Алгоритм:
    1. Генерируем случайное 512-битное нечетное число
    2. Проверяем его на простоту тестом Соловея-Штрассена
    3. Повторяем пока не найдем простое число
    """
    while True:
        # Генерируем случайное 512-битное число
        # getrandbits(512) дает случайное число указанной длины
        # | 1 гарантирует, что число будет нечетным (последний бит = 1)
        num = random.getrandbits(512) | 1  
        
        # Проверяем, что число действительно 512-битное
        # Если получилось меньше, устанавливаем старший бит
        if num < 2**511:  
            # (1 << 511) создает число с 1 в 512-й позиции
            # | устанавливает этот бит в num
            num |= (1 << 511)
            
        # Проверяем число на простоту тестом Соловея-Штрассена    
        if solovay_strassen_test(num):
            return num

def mod_exp(base: int, exp: int, mod: int) -> int:
    """
    Быстрое возведение в степень по модулю.
    base - основание
    exp - показатель степени 
    mod - модуль
    """
    # Особый случай - при модуле 1 всегда получаем 0
    # Любое число по модулю 1 всегда дает 0
    if mod == 1:
        return 0
    
    # Начальное значение результата
    result = 1
    # Приводим базу по модулю для оптимизации
    base = base % mod
    
    # Пока показатель степени не станет равным 0
    while exp > 0:
        # Если текущий бит показателя равен 1
        if exp & 1:
            # Умножаем результат на текущую базу
            result = (result * base) % mod
            
        # Возводим базу в квадрат для следующей итерации
        base = (base * base) % mod
        # Сдвигаем показатель вправо (делим на 2)
        exp >>= 1
        
    return result

def is_sophie_germain_prime(p: int) -> bool:
    """
    Проверка является ли число простым числом Софи Жермен.
    Число p является числом Софи Жермен, если:
    1. p - простое число
    2. 2p + 1 - тоже простое число
    
    Args:
        p (int): Проверяемое число
        
    Returns:
        bool: True если число является числом Софи Жермен, False иначе
    """
    # Сначала проверяем, является ли p простым
    if not solovay_strassen_test(p):
        return False
    # Затем проверяем, является ли 2p + 1 простым
    return solovay_strassen_test(2 * p + 1)

def generate_sophie_germain_primes(count: int) -> list:
    """
    Генерация заданного количества чисел Софи Жермен.
    
    Args:
        count (int): Требуемое количество чисел
        
    Returns:
        list: Список чисел Софи Жермен
    """
    primes = []
    # Начинаем с 3, так как 2 не подходит
    candidate = 3
    while len(primes) < count:
        # Проверяем каждое число на соответствие условиям
        if is_sophie_germain_prime(candidate):
            primes.append(candidate)
        # Увеличиваем на 2, так как четные числа (кроме 2)
        # не могут быть простыми
        candidate += 2
    return primes

def generate_generator() -> int:
    """
    Генерация генератора группы (числа Софи Жермен).
    Число p является числом Софи Жермен, если:
    1. p - простое число
    2. 2p + 1 - тоже простое число

    """
    primes = generate_sophie_germain_primes(10)  # Генерируем 10 чисел Софи Жермен
    return random.choice(primes)